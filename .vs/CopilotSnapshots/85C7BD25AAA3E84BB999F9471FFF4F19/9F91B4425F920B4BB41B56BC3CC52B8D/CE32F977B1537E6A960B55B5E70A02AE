// wwwroot/kaj-audio-particles.js
// Audio-reactive particle effect for Blazor KajWallpaper

let audioContext, analyser, sourceNode, dataArray, animationId;
let particleCanvas, ctx, particles = [];

function createParticles(count) {
    particles = [];
    for (let i = 0; i < count; i++) {
        particles.push({
            x: Math.random() * particleCanvas.width,
            y: Math.random() * particleCanvas.height,
            r: 2 + Math.random() * 3,
            dx: (Math.random() - 0.5) * 1.5,
            dy: (Math.random() - 0.5) * 1.5,
            color: `hsl(${Math.random()*360}, 80%, 60%)`
        });
    }
}

function drawParticles(volume, bass, treble) {
    ctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
    for (let i = 0; i < particles.length; i++) {
        let p = particles[i];
        // Maak grootte afhankelijk van bass, kleur van treble
        let dynamicR = p.r + bass * 8;
        let hue = (i * 360 / particles.length + treble * 120) % 360;
        ctx.beginPath();
        ctx.arc(p.x, p.y, dynamicR, 0, 2 * Math.PI);
        ctx.fillStyle = `hsl(${hue}, 80%, ${60 + treble*30}%)`;
        ctx.globalAlpha = 0.5 + volume * 0.5;
        ctx.fill();
        ctx.globalAlpha = 1;
        // Snelheid afhankelijk van volume
        p.x += p.dx * (1 + volume) + (Math.random()-0.5)*volume*2;
        p.y += p.dy * (1 + volume) + (Math.random()-0.5)*volume*2;
        if (p.x < 0 || p.x > particleCanvas.width) p.dx *= -1;
        if (p.y < 0 || p.y > particleCanvas.height) p.dy *= -1;
    }
}

function animateParticles() {
    if (!analyser) return;
    analyser.getByteFrequencyData(dataArray);
    let volume = 0;
    let bass = 0;
    let treble = 0;
    let bassCount = Math.floor(dataArray.length * 0.25);
    let trebleCount = Math.floor(dataArray.length * 0.25);
    for (let i = 0; i < dataArray.length; i++) volume += dataArray[i];
    for (let i = 0; i < bassCount; i++) bass += dataArray[i];
    for (let i = dataArray.length - trebleCount; i < dataArray.length; i++) treble += dataArray[i];
    volume = volume / dataArray.length / 255;
    bass = bass / bassCount / 255;
    treble = treble / trebleCount / 255;
    drawParticles(volume, bass, treble);
    animationId = requestAnimationFrame(animateParticles);
}

// AudioContext en bron delen voor alle audio-reactieve functies
let sharedAudioContext, sharedSourceNode, sharedAnalyserKaj, sharedAnalyserParticles, sharedAudioElement;

export async function startAudioParticles(audioSelector, canvasSelector) {
    particleCanvas = document.querySelector(canvasSelector);
    if (!particleCanvas) return;
    ctx = particleCanvas.getContext('2d');
    createParticles(48);
    let audio = document.querySelector(audioSelector);
    if (!audio) return;
    if (!sharedAudioContext) sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (!sharedSourceNode) {
        sharedSourceNode = sharedAudioContext.createMediaElementSource(audio);
        sharedAudioElement = audio;
    }
    if (!sharedAnalyserParticles) sharedAnalyserParticles = sharedAudioContext.createAnalyser();
    sharedAnalyserParticles.fftSize = 128;
    dataArray = new Uint8Array(sharedAnalyserParticles.frequencyBinCount);
    sharedSourceNode.connect(sharedAnalyserParticles);
    sharedAnalyserParticles.connect(sharedAudioContext.destination);
    analyser = sharedAnalyserParticles;
    animateParticles();
}

export function stopAudioParticles() {
    if (animationId) cancelAnimationFrame(animationId);
    if (ctx && particleCanvas) ctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
}

// Audio-reactive KAJ accordion letters
export async function startKajAccordionLetters(audioSelector, letterSelectors) {
    let audio = document.querySelector(audioSelector);
    if (!audio) return;
    let letters = letterSelectors.map(sel => document.querySelector(sel)).filter(Boolean);
    if (letters.length === 0) return;
    if (!sharedAudioContext) sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (!sharedSourceNode) {
        sharedSourceNode = sharedAudioContext.createMediaElementSource(audio);
        sharedAudioElement = audio;
    }
    // Gebruik een eigen analyser voor de letters, maar deel de bron
    if (!sharedAnalyserKaj) sharedAnalyserKaj = sharedAudioContext.createAnalyser();
    sharedAnalyserKaj.fftSize = 64;
    sharedSourceNode.connect(sharedAnalyserKaj);
    let dataArrayKaj = new Uint8Array(sharedAnalyserKaj.frequencyBinCount);
    function animateKajLetters() {
        sharedAnalyserKaj.getByteFrequencyData(dataArrayKaj);
        // Gebruik de bas als accordeon trigger
        let bass = (dataArrayKaj[2] + dataArrayKaj[3] + dataArrayKaj[4]) / (3 * 255);
        // Accordeon: K en J schuiven horizontaal uit elkaar, A blijft stabiel
        let maxOffset = 38; // pixels, hoe ver de letters maximaal uit elkaar gaan
        let offset = bass * maxOffset;
        let scaleY = 1 + bass * 0.10; // lichte puls
        if (letters[0]) letters[0].style.transform = `translateX(${-offset}px) scaleY(${scaleY})`;
        if (letters[1]) letters[1].style.transform = `translateX(0px) scaleY(${1 + bass * 0.05})`;
        if (letters[2]) letters[2].style.transform = `translateX(${offset}px) scaleY(${scaleY})`;
        requestAnimationFrame(animateKajLetters);
    }
    animateKajLetters();
}
